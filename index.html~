<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title></title>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width">
<!--    <link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.4.1/build/cssreset/cssreset-min.css"> -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="./css/codemirror.css">

    <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.1.min.js"></script>
    <script type="text/javascript" src="js/beautify.js"></script>
    <script type="text/javascript" src="js/examples.js"></script>
    <script type="text/javascript" src="js/micrograph.js"></script>
    <script type="text/javascript" src="js/codemirror.js"></script>
    <script type="text/javascript" src="js/modes/javascript.js"></script>
    <script type="text/javascript">
      jQuery(document).ready(function() {
          var exampleIDs = ["ex1", "ex2", "ex3", "ex4", "ex5", "ex6", "ex7", "ex8", "ex9",
                            "ex10", "ex11", "ex12", "ex13", "ex14", "ex15", "ex16", "ex17",
			    "ex18", "ex19", "ex16b"];
          for(var i=0; i<exampleIDs.length; i++) {
	      var id = exampleIDs[i];
	      if(window.examples[id].source) {
		  window['source'+id] = CodeMirror(jQuery("#"+id+" .source-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      value: window.examples[id].source
		  });
	      }
	      if(window.examples[id].data && window.examples[id].data !== true) {
  		  window['data'+id] = CodeMirror(jQuery("#"+id+" .data-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      value: js_beautify(window.examples[id].data)
		  });
	      }
	      if(window.examples[id].data) {
  		  window['output'+id] = CodeMirror(jQuery("#"+id+" .output-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      readOnly: true,
		      value: ''
		  });
	      }
	  }

	  var handlers = {
	      loadAndEvaluate: function(root) {	
		  mg.create(function(g) {
		      var result = null;
		      var output = function(obj) {
			  result = obj;
		      }
		      try {			    
			  var query = window[root.replace("#","source")].getValue();
			  eval("var data="+window[root.replace("#","data")].getValue());
			  g.load(data);
			  eval(query);

                      } catch(e) {
			  console.log(e);
			  output("EXCEPTION: "+e);
                      }
		      window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
		      window[root.replace("#","output")].refresh();
		  });
	      },
	      evaluate:  function(root) {
		  mg.create(function(g) {
		      var result = null;
		      var output = function(obj) {
			  result = obj;
		          window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
  		          window[root.replace("#","output")].refresh();
		      }
		      try {
			  var query = window[root.replace("#","source")].getValue();
			  eval(query);
		      } catch(e) {
			  console.log(e);
			  output("EXCEPTION: "+e);
		      }
		  });
	      }
	  }

	  var handlersMap = {
	      "#ex1": handlers.loadAndEvaluate,
	      "#ex2": handlers.loadAndEvaluate,
	      "#ex5": handlers.evaluate,
	      "#ex6": handlers.evaluate,
	      "#ex7": handlers.evaluate,
	      "#ex8": handlers.evaluate,
	      "#ex9": handlers.evaluate,
	      "#ex10": handlers.loadAndEvaluate,
	      "#ex11": handlers.loadAndEvaluate,
	      "#ex12": handlers.loadAndEvaluate,
	      "#ex13": handlers.loadAndEvaluate,
	      "#ex14": handlers.loadAndEvaluate,
	      "#ex15": handlers.loadAndEvaluate,
	      "#ex16": handlers.loadAndEvaluate,
	      "#ex16b": handlers.loadAndEvaluate,
	      "#ex17": handlers.loadAndEvaluate,
	      "#ex18": handlers.loadAndEvaluate,
	      "#ex19": handlers.loadAndEvaluate
	  };

	  var tabs = function(root) {
	      $(root+" .tabs-options a").bind('click', function(e) {
		  $(root+" .tabs-options .selected-tab").removeClass('.selected-tab');
		  var css = $(e.target).attr("class").split(" ")[0];
		  $(e.target).addClass('selected-tab');
		  $(root+" .tab-content").hide();
		  $(root+" ."+css+"-content").show();
		  if(css === "output-tab") {
		      window[root.replace("#","output")].setValue("//loading...");
		      window[root.replace("#","output")].refresh();
		      handlersMap[root](root)
		  } else {
		      window[root.replace("#",css.split("-tab")[0])].refresh();
		  }
		  return false;
	      });
	  };

	  for(var i=0; i<exampleIDs.length; i++)
	      tabs('#'+exampleIDs[i]);
      });
  </script>

  </head>
  <body>
    <div id="header">
      <header class="wrapper clearfix">
	<h1>micrograph.js</h1>
      </header>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
	<div id="index" class="span2">
	  <!--Sidebar content-->
	  <ol>
	    <li><a href="#introduction">Basic Concepts</a></li>
	    <li><a href="#data_loading">Data Loading</a></li>
	    <li><a href="#queries">Queries</a></li>
	    <li><a href="#updates">Data Modification</a></li>
	  </ol>
	</div>
	<div id="content" class="span10">
	  <!--Body content-->
	  <div class="row">
	    <div class="span10">
	      <h2 id="introduction">Basic Concepts</h2>
	      Micrograph.js is a JavaScript library providing a data graph layer for JSON objects. It implements functions for data retrieval, querying, traversal and transformation of data. JSON objects from different resources or even different APIs can be linked in the graph using properties values or transformations of these properties. The library also implements an event system that makes possible to register observer functions that will be notified after certain modifications of the data graph. Finally a system of classes makes possible to associate behaviour to the graph data.

	      <h3>JSON objects, identity and  special properties</h3>
	      The library is designed to work with plain JSON objects without any additinal or special purpose notation. These JSON objects are inserted as nodes into the graph of data. However one of the main drawbacks of the use of JSON as an exchange format is the lack of identity of JSON objects. This is a problem in many situations, for example, when trying to establish a relationship between objects. In those cases, most APIs use a property in the objects as an ad-hoc identifier. Micrograph.js uses a special property <code>$id</code> to associate an identity to every object loaded in the graph. If the object being loaded does not include a value for this property, a new identifier will be generated and associated to the object when it is loaded into the graph. 
	      Additionally the library uses a set of special attributes to add semantic information to the objects loaded into the graph. These properties are optional and some of them will be added dinamically by the library when objects are loaded into the graph:
	      <ul>
		<li><code>$id</code>: Unique object identifier</li>
		<li><code>$type</code>: Types associated to the object</li>
		<li><code>$from</code>: Source of the objects</li>
		<li><code>$state</code>: State of the object compared with its data source. It can have different values, <code>created</code>, <code>loaded</code> and <code>modified</code> indicating respectively that the object has been created and it is not associated to any remote resource, that it has been loaded from a remote resource and it hasn't been modified or that it has been loaded and then modified locally.</li>
	      </ul>

	      <h3>Queries</h3>
	      Micrograph.js supports two different kinds of queries: node queries and tuple queries.
	      
	      When objects are loaded into the graph, they are decomposed into a set of simple logical assertions about those objects. Node queries can be thought as templates, encoded as JSON objects, for the nodes we want to retrieve that will be filled with a consistent collection of the assertions stored in the graph. The output of the query is a collection of JSON objects collecting the assertions for the nodes matched by the query template.
	      
	      The following query is an example of a query that retrieves all the books in the graph:

	      <div class="example row" id="ex1">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex1-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex1-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex1-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	    Tuple queries on the other hand receive a query pattern including some variables and return all tuples with bindings for those variables in the graph. The following example uses a tuple query to loook for relationships between authors and books:

	      <div class="example row" id="ex2">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		<div id="ex2-source-tab" class="tab-content source-tab-content span11"></div>
		<div id="ex2-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		<div id="ex2-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3 id="creation">Graph Creation</h3>
	      To create a new graph, the function <code>create</code> can be used as shown in the following example:

	      <div class="example row" id="ex3">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		  </ul>
		</div>
		<div class="row">
		<div id="ex3-source-tab" class="tab-content source-tab-content span11"></div>
		</div>
	      </div>

	      The library supports the creation of persistent graphs using W3C's <a href="http://www.w3.org/TR/webstorage/">Web Storage</a> recommendation. In order to create a persistent graph or open an already persisted graph, the function <code>open</code> must be used instead of <code>create</code>. This function accepts a name for the graph, flag indicating if the data in the graph must be overwritten, an optional hash of parameters and the completion callback:

	      <div class="example row" id="ex4">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		  </ul>
		</div>
		<div class="row">
		<div id="ex4-source-tab" class="tab-content source-tab-content span11"></div>
		</div>
	      </div>

	    </div>
	  </div> <!-- end of graph basic concepts -->

	  <div class="row">
	    <div class="span11">
	      <h2 id="data_loading">Data Loading</h2>

	      Adding new data to the graph can be accomplished using the <code>load</code> function. The function accepts a single object or an array of JSON objects. The function accepts a callback that will be invoked once the data is retrieved and loaded into the graph. The following example shows how a simple array of objects can be loade into the store:

	      <div class="example row" id="ex5">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex5-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex5-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Loading Data from the Web</h3>
	      
	      The library supports loading data from remote resources through AJAX, AJAX+CORS or JSONP requests. The location where data must be retrieved must be set using the <code>from</code> function before invoking the <code>load</code> function that performs the actual retrieval. <code>from</code> accepts two parameters, the remote URL string and an optional hash of parameters. If the URL string includes a 'callback' HTTP request parameter name, a JSONP callback will be triggered automatically. Otherwise an AJAX request will be performed. If the JSONP request must use a different callback name, it can be passed in the options hash.

              The following example retrieves some data from Github's API and stores it in the graph. After loading the objects the <code>$from</code> property in the nodes created will point to the original URI where objects were retrieved from. All objects will also be assigned an unique <code>$id</code> property and the <code>$state</code> property for the objects will be set to the value <clode>loaded</code>.

	      <div class="example row" id="ex6">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex6-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex6-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      The <code>from</code> function accepts a single string URI but can also accept an array containing multiple URIs that will be loaded sequentially. After all data is loaded, the following callback function provided by the user will be invoked receiving the accumulated data.

	      <h3>Transforming Retrieved Data</h3>
	      Many times it is desirable to perform some kind of transformation on the data retrieved from a remote resource before inserting that data in the graph. Most APIs also include properties in the objects semantically equivalent to the <code>$type</code> and <code>$id</code> properties supported by micrograph.js. It is also interesting to map the original object properties to these special properties before loading the objects, specially if we try to link objects from different APIs. The most direct way to perform transformations on the feched data using the library is to pass a callback to the <code>from</code> function that will receive the retrieved objects without loading them into the store, transform the data and then insert the data into the graph. Additionally, the library provides the <code>transform</code> function, that will iterate through the properties of the loaded objects giving the user the chance to transform the objects linked to those properties. 
	      The following example shows how repository data loaded from Github can be transformed before inserting it into the graph using the <code>transform</code> function.
	     
	      <div class="example row" id="ex7">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex7-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex7-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Anothe possibility supported by the library is to pass a declarative transformation instead of a function to the <code>transform</code> function. A declarative transformation is just a JSON object where certain actions are declared for the properties of the loaded objects. Available transformations include:
	      <ul>
		<li><code>@id</code>: associates the value of the this property as the <code>$id</code> property of the object</li>
		<li><code>@type</code>: associates the value of the this property as the <code>$type</code> property of the object</li>
		<li><code>@delete</code>: deletes the associated key from the object</li>
		<li><code>propertyName</code>: an action associated to the provided property</li>
	      </ul>

	      Actions associated to these keys can be strings with the name of a property in the object or a function. If a string is passed the value for that property in the object will be used in the action. If a function is associated, it will be evaluated, passing the object as an argument, and the result used in th action.

	      The following example shows an equivalent transformation of the Github's repository API but using a declarative transformation instead of a function to transform the incoming data:

	      <div class="example row" id="ex8">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex8-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex8-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Error notifications</h3>
	      If an error is obtained retrieving web data, it will be notified to any callback added to the graph using the <code>onError</code> function, along with the error message obtained, as the following example shows:

	      <div class="example row" id="ex9">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex9-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex9-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      

	    </div>
	  </div> <!-- end of data loading -->

	  <div class="row">
	    <div class="span11">
	      <h2 id="queries">Queries</h2>

	      Queries over the data graph are initiated using the <code>where</code> function accepting a query pattern as an argument. The <code>where</code> function can be used to describe patterns for the two kind of queries supported by the store: node queries and tuple queris.
	      
	      After defining a node query, results can be retrieved, iterated and filtered using a collection of functions like <code>all</code>, <code>each</code>, <code>first</code>, <code>select</code>, <code>map</code> and <code>reduce</code>. In the case of tuples queries, results can be retrieved using the <code>tuples</code> function.


	    <h3>Node Queries</h3>

	    Node queries return JSON objects encoding the data assertions associated to the graph nodes matching the template passed as an argument to the <code>where</code> function. The most general pattern that can be specified is an empty JSON object <code>{}</code> that will match every node in the graph. The following example shows how this query can be used to retrieve all the information stored in the data graph:

	      <div class="example row" id="ex10">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex10-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex10-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex10-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>


	      More complex queries are built adding restrictions to the node patterns. The most basic restriction consists of binding a property to a fixed value. Only the nodes matching that value on some data abstraction will be returned.
	      In the following example we recover only people stored in the graph adding that restriction on the <code>$type</code> property:

	      <div class="example row" id="ex11">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex11-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex11-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex11-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      If the returned nodes are linked to different nodes through some property, the linked objects are returned as JSON objects containing only the <code>$id</code> property of the linked object. In order to retrieve linked objects, additional JSON objects must be added to the query template. These templates can also contain restrictions or link themselves to more nodes.

	      The following example retrieves all the people from the graph born in the UK that have published andy book:

	      <div class="example row" id="ex12">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex12-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex12-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex12-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Inverse Properties</h3>
	      
	      micrograph.js supports the insertion of <it>inverse properties</it> in query templates. Inverse properties makes it possible to treat every property in a JSON object loaded in the graph as if the linked object had declared an additional property linking back to the original object. Inverse properties are specified in templates using the suffix <code>$in</code> to the name of the property.
	      The following example uses inverse properties to retrieve the winners of the Nobel Prize born in each country stored in the graph:

	      <div class="example row" id="ex13">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex13-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex13-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex13-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Data Types</h3>
	      The library supports the main JavaScript data types as values: strings, numbers (floats), boolean, dates, arrays and <code>null</code> values. The following example shows how different values can be inserted and queried using the library:

	      <div class="example row" id="ex14">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex14-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex14-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex14-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>



	      The library treats properties as sets of values. If two assertions for the same property of the same node are loaded into the graph, the returned representation for that node will include an array with both values. In the same way, loading a JSON object with an array as value will be transformed in as many data assertions as elements are in the array. Since property values are sets, it also means that there cannot be duplicated values. In order to model duplicated values or impose a certain order in the values of a property, values must be transformed into proper nodes.
	      
	      <h3>Filters</h3>

	      Besides exact value matching restrictions, more expressive restrictions can be added to query templates using filters. Filters are encoded in templates as JSON objects with a single filter property. Available filters are:

	      <ul>
		<li><code>$eq</code>: equality</li>
		<li><code>$neq</code>: inequality</li>
		<li><code>$gt</code>: greater than</li>
		<li><code>$gte</code>: greater than or equals</li>
		<li><code>$lt</code>: less than</li>
		<li><code>$lte</code>: less than or equals</li>
		<li><code>$like</code>: regular expression matching</li>
	      </ul>

	      More complex filters can be composed using the following connectors:

	      <ul>
		<li><code>$and</code>: conjunction</li>
		<li><code>$or</code>: disjunction</li>
		<li><code>$not</code>: negation</li>
	      </ul>

	      The following example shows how filters can be used to retrieve certain nodes from the graph representing words in different languages:

	      <div class="example row" id="ex15">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex15-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex15-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex15-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Results Processing</h3>
	      
	      Once a query template has been defined using the <code>where</code> function, evaluation of the query can be trigerred using the <code>all</code> or <code>first</code> functions. Both functions accept a callback as a parameter where all the nodes matching the query in the case of the <code>all</code> function or the first node in the case of the <code>first</code> function will be returned. If no node matches the query the callbacks will receive an empty array and <code>null</code> respectively.

	      Additionally, a <it>post-processing</it> function can be specified if the query is triggered using th <code>all</code> function. This function will be used to transform the query result before passing the transformed to the <code>all</code> function.

	      The available post-processsing functions are:

	      <ul>
		<li><code>map</code>: It will be invoked for each obtained result and the output collected and then passed to the <code>all</code>/ function.</li>
		<li><code>each</code>: It will be invoked for each obtained result. Invoked only for side-effects.</li>
		<li><code>select</code>: The callback function passed to this funciton must be a predicate returning <code>true</code> or <code>false</code>. It will be applied to each result and only nodes evaluted to <code>true</code> by the predicate will be returned.</li>
		<li><code>reduce</code>: Accepts an initial value and a callback that will e used to reduce the results collection. The final value of the acumulator will be returned to the <code>all</code> function.
		<li><code>groupBy</codE>: Groups the results, using the provided name of property or function predicate. The final result will be a JSON objects with as many properties as groups are collected.
	      </ul>

	      The following examples shows how post-processing function can be used to transform the final result of a query:

	      <div class="example row" id="ex16">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex16-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex16-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex16-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Multiple post-processing function can be specified and they will be applied in the same definition order to the query results. The only exception is the <code>groupBy</code> function that will only be applied once as the final post-processing step.

	      The following example shows how different functions can be applied to the initial results:

	      <div class="example row" id="ex16b">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex16b-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex16b-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex16b-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Order and Pagination</h3>
	      
	      Sometimes it is convenient to retrieve only a subset of the results of a query. Micrograph.js supports this functionality using the <code>limit</code> and <code>offset</code> functions. These two functions can be used to paginate the results obtained from the graph.
	      Since collections of nodes are manipulated like sets by the library it is required to impose an order in the collection to retrieve a meaninful partition of the nodes, the <code>order</code> function can be used to transform the set of resulting nodes into an ordered collection.

	      The following shows the use of pagination with a simple collection of objects:

	      <div class="example row" id="ex17">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex17-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex17-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex17-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Tuple Queries</h3>

	      Tuple queries are similar to node queries but instead of returning full nodes as JSON objects return all the possible combinations of values for selected properties in the query template. The values to return must be marked using variables. Variables can be created using the <code>_</code> (underscore) function of the graph object. The <code>_</code> function receives as an argument a name for the variable that will be returned later as the property name in the bindings returned in the solution. As a convenience variables from <code>_a</code> to <code>_z</code> are already defined as properties of the graph object. 

	      To trigger the query, the <code>tuples</code> function must be invoked. Filters, pagination and the rest of query utilities are also available for tuple queries.

	      The following example shows how tuple queries can be used combined with other query utilities:

	      <div class="example row" id="ex18">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex18-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex18-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex18-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>


	      <h3>Traversals</h3>
	      
	      Simple graph traversals are supported by the library and can be inserted into query patterns through path expressions. Path expressions consist of a series of properties separated by the <code>/</code> (slash) symbol plus some additional wildcards: 
	      <ul>
		<li><code>*</code> 0..n occurrences of the property.</li>
		<li><code>?</code> 0..1 occurrences of the property.</li>
		<li><code>+</code> 1..n occurrences of the property.</li>
	      </ul>
	      Paths can be inserted into node and tuple queries but can also be used with the <code>traverse</code> function to retrieve pairs of nodes collected by the graph traversal. Additionally the functions <code>startNode</code> or <code>endNode</code> can be used to bind the initial or final node of the traversal.

	      Traversals can be triggered using the <code>tuples</code> or <code>all</code> functions that will return plain tuples of full nodes as the result of the traversal in each case.

	      The following examples shows how traversals can be used to query hierachical data structures stored in the graph:

	      <div class="example row" id="ex19">
		<div class="tabs-options span11">
		  <ul>
		    <li><a href="#" class="source-tab selected-tab">source</a></li>
		    <li><a href="#" class="data-tab">data</a></li>
		    <li><a href="#" class="output-tab">output</a></li>
		  </ul>
		</div>
		<div class="row">
		  <div id="ex19-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex19-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex19-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      

	    </div>
	  </div> <!-- end of queries -->

	  <div>
	    <div class="span10">
	      <h2 id="updates">Data Modification</h2>
	      
	      The library offers three main methods to modify the state of the graph. The <code>load</code> function is used to insert new information into the graph
	  </div> <!-- end of data modification -->
	</div>
      </div>



    </div> <!-- /container -->
      <script>
	//var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
	//(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
	//g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
	//s.parentNode.insertBefore(g,s)}(document,'script'));
      </script>
  </body>
</html>
