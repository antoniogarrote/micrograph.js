<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title></title>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width">

    <style>
       body {
           font: 16px/26px Helvetica,Helvetica Neue,Arial;
       }
        
       .tabs-options {
           margin-top: 20px;
           margin-bottom: 10px
       }
        
       .tabs-options span {
           padding: 10px;
           margin-bottom: 10px;
       }
        
       .example {
           margin-left: 18px;
           margin-bottom: 10px
       }
    </style>
    <Link rel="stylesheet" href="./css/codemirror.css">
    <link rel="stylesheet" href="css/bootstrap-responsive.min.css">

    <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.1.min.js"></script>
    <script type="text/javascript" src="js/beautify.js"></script>
    <script type="text/javascript" src="js/examples.js"></script>
    <script type="text/javascript" src="js/micrograph_min.js"></script>
    <script type="text/javascript" src="js/n3_min.js"></script> 
    <script type="text/javascript" src="js/codemirror.js"></script>
    <script type="text/javascript" src="js/modes/javascript.js"></script>
    <script type="text/javascript" src="js/jsonStringify.js"></script>
    <script type="text/javascript">
      jQuery(document).ready(function() {
          var exampleIDs = ["ex1", "ex2", "ex3", "ex4", "ex5", "ex6", "ex7", "ex8", "ex9",
                            "ex10", "ex11", "ex12", "ex13", "ex14", "ex15", "ex16", "ex17",
			    "ex18", "ex19", "ex16b", "ex20", "ex21", "ex22", "ex23", "ex24",
			    "ex25", "ex25b", "ex26", "ex27", "ex28", "ex29"];

          for(var i=0; i<exampleIDs.length; i++) {
	      var id = exampleIDs[i];
	      if(window.examples[id].source) {
		  window['source'+id] = CodeMirror(jQuery("#"+id+" .source-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      value: window.examples[id].source
		  });
	      }
	      if(window.examples[id].data && window.examples[id].data !== true) {
  		  window['data'+id] = CodeMirror(jQuery("#"+id+" .data-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      value: js_beautify(window.examples[id].data)
		  });
	      }
	      if(window.examples[id].data) {
  		  window['output'+id] = CodeMirror(jQuery("#"+id+" .output-tab-content").get(0), {
		      smartIndent: true,
		      lineNumbers: true,
		      mode: "javascript",
		      readOnly: true,
		      value: ''
		  });
	      }
	  };

	  //var purge = function(res) {
          //};

	  var handlers = {
	      loadAndEvaluate: function(root) {	
		  mg.create(function(g) {
		      var result = null;
		      var output = function(obj) {
			  result = obj;
		      }
		      try {			    
			  var query = window[root.replace("#","source")].getValue();
			  eval("var data="+window[root.replace("#","data")].getValue());
			  g.load(data);
			  eval(query);

                      } catch(e) {
			  output("EXCEPTION: "+e);
                      }
		      window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
		      window[root.replace("#","output")].refresh();
		  });
	      },

	      evaluate:  function(root) {
		  mg.create(function(g) {
		      var result = null;
		      var output = function(obj) {
			  
			  JSONstring.compactOutput=false;     
			  JSONstring.includeProtos=false;	  
			  JSONstring.includeFunctions=false;     
			  JSONstring.detectCirculars=true;		
			  JSONstring.restoreCirculars=true;
			  
			  var s=JSONstring.make(obj);

		          window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(JSON.parse(s))));
  		          window[root.replace("#","output")].refresh();
		      }
		      try {
			  var query = window[root.replace("#","source")].getValue();
			  eval(query);
		      } catch(e) {
		          debugger;
			  output("EXCEPTION: "+e);
		      }
		  });
	      },

	      periodical:  function(root) {
		  mg.create(function(g) {
		      var result = [];
		      var counter = 0;
		      var output = function(obj) {
			  counter++;
			  if(counter === 15) {
			      result.push("! max evaluations reached. Aborting");
		              window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
  		              window[root.replace("#","output")].refresh();
			  } else if(counter<15) {			      
			      result.push(obj);
		              window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
  		              window[root.replace("#","output")].refresh();
			  }
		      }
		      try {
			  var query = window[root.replace("#","source")].getValue();
			  eval(query);
		      } catch(e) {
			  debugger;
			  output("EXCEPTION: "+e);
		      }
		  })
	      },

	      loadAndPeriodical:  function(root) {
		  mg.create(function(g) {
		      var result = [];
		      var counter = 0;
		      var output = function(obj) {
			  counter++;
			  if(counter === 15) {
			      result.push("! max evaluations reached. Aborting");
		              window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
  		              window[root.replace("#","output")].refresh();
			  } else if(counter<15) {			      
			      result.push(obj);
		              window[root.replace("#","output")].setValue(js_beautify(JSON.stringify(result)));
  		              window[root.replace("#","output")].refresh();
			  }
		      }
		      try {			    
			  var query = window[root.replace("#","source")].getValue();
			  eval("var data="+window[root.replace("#","data")].getValue());
			  g.load(data);
			  eval(query);

                      } catch(e) {
			  output("EXCEPTION: "+e);
                      }
		  })
	      }
	  }

	  var handlersMap = {
	      "#ex1": handlers.loadAndEvaluate,
	      "#ex2": handlers.loadAndEvaluate,
	      "#ex5": handlers.evaluate,
	      "#ex6": handlers.evaluate,
	      "#ex7": handlers.evaluate,
	      "#ex8": handlers.evaluate,
	      "#ex9": handlers.evaluate,
	      "#ex10": handlers.loadAndEvaluate,
	      "#ex11": handlers.loadAndEvaluate,
	      "#ex12": handlers.loadAndEvaluate,
	      "#ex13": handlers.loadAndEvaluate,
	      "#ex14": handlers.loadAndEvaluate,
	      "#ex15": handlers.loadAndEvaluate,
	      "#ex16": handlers.loadAndEvaluate,
	      "#ex16b": handlers.loadAndEvaluate,
	      "#ex17": handlers.loadAndEvaluate,
	      "#ex18": handlers.loadAndEvaluate,
	      "#ex19": handlers.loadAndEvaluate,
	      "#ex20": handlers.loadAndEvaluate,
 	      "#ex21": handlers.loadAndEvaluate,
 	      "#ex22": handlers.loadAndEvaluate,
	      "#ex23": handlers.periodical,
	      "#ex24": handlers.loadAndPeriodical,
	      "#ex25": handlers.periodical,
	      "#ex25b": handlers.periodical,
	      "#ex26": handlers.loadAndPeriodical,
	      "#ex27": handlers.evaluate,
	      "#ex28": handlers.evaluate,
	      "#ex29": handlers.evaluate
	  };

	  var tabs = function(root) {
	      $(root+" .tabs-options a").bind('click', function(e) {
		  $(root+" .tabs-options .selected-tab").removeClass('.selected-tab');
		  var css = $(e.target).attr("class").split(" ")[0];
		  $(e.target).addClass('selected-tab');
		  $(root+" .tab-content").hide();
		  $(root+" ."+css+"-content").show();
		  if(css === "output-tab") {
		      window[root.replace("#","output")].setValue("//loading...");
		      window[root.replace("#","output")].refresh();
		      handlersMap[root](root)
		  } else {
		      window[root.replace("#",css.split("-tab")[0])].refresh();
		  }
		  return false;
	      });
	  };

	  for(var i=0; i<exampleIDs.length; i++)
	      tabs('#'+exampleIDs[i]);
      });
  </script>

  </head>
  <body>
    <div id="header">
      <header class="wrapper clearfix">
	<h1>micrograph.js</h1>
	<div style="margin-left:10px">
	  <a href="doc/index.html">jsdoc</a>
	  |
	  <a href="mg.tar.gz">download</a>
          |
	  <a href="https://github.com/antoniogarrote/micrograph.js">source</a>
	</div>
      </header>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
	<div id="index" class="span2">
	  <!--Sidebar content-->
	  <ol>
	    <li><a href="#introduction">Introduction</a></li>
	    <li><a href="#data_loading">Data Loading</a></li>
	    <li><a href="#queries">Queries</a></li>
	    <li><a href="#updates">Data Modification</a></li>
	    <li><a href="#events">Events</a></li>
	    <li><a href="#classes">Classes</a></li>
	    <li><a href="#microdata">Microdata</a></li>
	    <li><a href="#rdf">RDF</a></li>
	  </ol>
	</div>
	<div id="content" class="span10">
	  <!--Body content-->
	  <div class="row">
	    <div class="span10">
	      <h2 id="introduction">Introduction</h2>
	      Micrograph.js is a JavaScript library providing a data graph layer for JSON objects, Microdata and RDF data. It implements functions for data retrieval, querying, traversal and transformation of data. Information from different resources or even different APIs can be linked in the graph using property values or transformations of these properties. The library also implements an event system allowing to register observer functions that will be notified after certain modifications of the data graph. Finally, a system of classes makes possible to associate behaviour to the graph data.

	      <h3>JSON objects, identity and  special properties</h3>
	      The library is designed to work with plain JSON objects without any additional or special purpose notation. These JSON objects are inserted as nodes into the graph of data. One of the main drawbacks of the use of JSON as an exchange format is the absence of an explicit identifier for JSON objects. This is a problem in many situations, for example, when trying to establish a relationship between objects. In those cases, most APIs use a property in the objects as an ad-hoc identifier. Micrograph.js uses a special property <code>$id</code> to associate an identity to every object loaded in the graph. If the object being loaded does not include a value for this property, a new identifier will be generated and associated to the object when it is loaded into the graph. 
	      Additionally, the library uses a set of special attributes to attach semantic information to the objects loaded into the graph. These properties are optional and some of them will be added dynamically by the library:
	      <ul>
		<li><code>$id</code>: Unique object identifier</li>
		<li><code>$type</code>: Types associated to the object</li>
		<li><code>$from</code>: Source of the objects</li>
		<li><code>$state</code>: State of the object compared to its data source. It can have different values, <code>created</code>, <code>loaded</code> and <code>modified</code> indicating respectively that the object has been created and it is not associated to any remote resource, that it has been loaded from a remote resource and it hasn't been modified or that it has been loaded and then modified locally.</li>
	      </ul>

	      <h3>Queries</h3>
	      Micrograph.js supports two different kind of queries: node queries and tuple queries.
	      <br/>	      
	      When objects are loaded into the graph, they are decomposed into a set of simple logical assertions about those objects. Node queries can be thought of as templates, encoded as JSON objects, for the nodes that must be retrieved.Patterns will be filled with a consistent collection of the assertions stored in the graph. The final output of the query is a collection of JSON objects collecting the assertions for the nodes matched by the query template.
	      <br/>	      
	      The following query is an example of a query that retrieves all the books in the graph:

	      <div class="example row" id="ex1">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex1-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex1-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex1-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	    Tuple queries on the other hand receive a query pattern including some variables and return all tuples with bindings for those variables in the graph. The following example uses a tuple query to look for relationships between authors and books:

	      <div class="example row" id="ex2">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		<div id="ex2-source-tab" class="tab-content source-tab-content span11"></div>
		<div id="ex2-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		<div id="ex2-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3 id="creation">Graph Creation</h3>
	      To create a new graph, the function <code>create</code> can be used as shown in the following example:

	      <div class="example row" id="ex3">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		  </div>
		</div>
		<div class="row">
		<div id="ex3-source-tab" class="tab-content source-tab-content span11"></div>
		</div>
	      </div>

	      The library supports the creation of persistent graphs using W3C's <a href="http://www.w3.org/TR/webstorage/">Web Storage</a> recommendation. In order to create a persistent graph or open an already persisted graph, the function <code>open</code> must be used instead of <code>create</code>. This function accepts a name for the graph, a flag indicating if the data in the graph must be overwritten, an optional hash of parameters and the completion callback:

	      <div class="example row" id="ex4">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		  </div>
		</div>
		<div class="row">
		<div id="ex4-source-tab" class="tab-content source-tab-content span11"></div>
		</div>
	      </div>

	    </div>
	  </div> <!-- end of graph basic concepts -->

	  <div class="row">
	    <div class="span11">
	      <h2 id="data_loading">Data Loading</h2>

	      Adding new data to the graph can be accomplished using the <code>load</code> function. The function accepts a single object or an array of JSON objects. The function accepts a callback that will be invoked once the data is retrieved and loaded into the graph. The following example shows how a simple array of objects can be loaded into the store:

	      <div class="example row" id="ex5">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex5-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex5-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Loading Data from the Web</h3>
	      
	      The library supports loading data from remote resources through AJAX, AJAX + <a href="http://www.w3.org/TR/cors/">CORS</a> or JSONP requests. The location where data will be retrieved from must be set using the <code>from</code> function before invoking the <code>load</code> function that performs the actual retrieval. <code>from</code> accepts two parameters: the remote URL string and an optional hash of parameters. If the URL string includes a 'callback' HTTP request parameter name, a JSONP callback will be triggered automatically. Otherwise an AJAX request will be performed. If the JSONP request must use a different callback name, it can be passed in the options hash.
	      <br/>
              The following example retrieves some data from Github's API and stores it in the graph. After loading the objects the <code>$from</code> property in the newly created nodes will point to the original URI where objects were retrieved from. All objects will also be assigned an unique <code>$id</code> property and the <code>$state</code> property for the objects will be set to the value <clode>loaded</code>.

	      <div class="example row" id="ex6">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex6-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex6-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      The <code>from</code> function accepts a single string URI but it can also accept an array containing multiple URIs that will be loaded sequentially. After all data is loaded, the following callback function provided by the user will be invoked receiving the accumulated data.

	      <h3>Transforming Retrieved Data</h3>

	      Iit is often desirable to perform some kind of transformation on the data retrieved from a remote resource before inserting that data in the graph. For example, most APIs include properties in the objects semantically equivalent to the <code>$type</code> and <code>$id</code> properties supported by micrograph.js. These properties can be mapped to the special properties before loading the objects, specially if we try to link objects from different APIs. The most direct way to apply a  transformation to the fetched data using the library is to pass a callback to the <code>from</code> function. This function will receive the retrieved objects before they are inserted in the graph. 
<br/>
Additionally, the library provides the <code>transform</code> function, that will iterate through the properties of the loaded objects giving the user the chance to transform the objects linked to those properties. 
	      <br/>
	      The following example shows how <a href="http://developer.github.com/v3/repos/">repository data</a> loaded from <a href="http://developer.github.com/v3/">Github</a> can be transformed before inserting it into the graph using the <code>transform</code> function.
	     
	      <div class="example row" id="ex7">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex7-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex7-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Another possibility supported by the library is to pass a declarative transformation instead of a function to the <code>transform</code> function. A declarative transformation is just a JSON object where certain actions are declared to be executed for the properties of the loaded objects. Available transformations include:
	      <ul>
		<li><code>@id</code>: associates the value of the this property as the <code>$id</code> property of the object</li>
		<li><code>@type</code>: associates the value of the this property as the <code>$type</code> property of the object</li>
		<li><code>@delete</code>: deletes the associated key from the object</li>
		<li><code>propertyName</code>: an action associated to the provided property</li>
	      </ul>

	      Actions associated to these keys can be strings with the name of a property in the object or a function. If a string is passed the value for that property in the object will be used in the action. If a function is associated, it will be evaluated, passing the object as an argument, and the result used in the action.
	      <br/>
	      The following example shows an equivalent transformation of the Github's repository API but using a declarative transformation instead of a function to transform the incoming data:

	      <div class="example row" id="ex8">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex8-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex8-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Error notifications</h3>
	      If an error is raised while retrieving web data, it will be notified to any callback added to the graph using the <code>onError</code> function, along with the error message obtained, as the following example shows:

	      <div class="example row" id="ex9">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex9-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex9-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      

	    </div>
	  </div> <!-- end of data loading -->

	  <div class="row">
	    <div class="span11">
	      <h2 id="queries">Queries</h2>

	      Queries over the data graph are initiated using the <code>where</code> function accepting a query pattern as an argument. The <code>where</code> function can be used to describe patterns for the two kind of queries supported by the store: node queries and tuple queries.
	      <br/>
	      After defining a node query, results can be retrieved, iterated and filtered using a collection of functions like <code>all</code>, <code>each</code>, <code>first</code>, <code>select</code>, <code>map</code> and <code>reduce</code>. In the case of tuples queries, results can be retrieved using the <code>tuples</code> function.


	    <h3>Node Queries</h3>

	    Node queries return JSON objects encoding the data assertions associated to the graph nodes matching the template passed as an argument to the <code>where</code> function. The most general pattern that can be specified is an empty JSON object <code>{}</code> that will match every node in the graph. The following example shows how this query can be used to retrieve all the information stored in the data graph:

	      <div class="example row" id="ex10">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex10-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex10-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex10-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>


	      More complex queries are built adding restrictions to the node patterns. The most basic restriction consists of binding a property to a fixed value. Only the nodes matching that value on some data node will be returned.
	      In the following example only people stored in the graph will be returned after adding that restriction on the <code>$type</code> property:

	      <div class="example row" id="ex11">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex11-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex11-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex11-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      If the returned nodes are linked to different nodes through some property, the linked objects are returned as JSON objects containing only the <code>$id</code> property of the linked object. In order to retrieve the full linked objects, additional JSON objects must be added to the query template. These templates can also contain restrictions or link themselves to more nodes.
	      <br/>
	      The following example retrieves all the people from the graph born in the UK that have published any book:

	      <div class="example row" id="ex12">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex12-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex12-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex12-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Inverse Properties</h3>
	      
	      Micrograph.js supports the insertion of <i>inverse properties</i> in query templates. Inverse properties makes it possible to treat every property in a JSON object loaded in the graph as if the linked object had declared an additional property linking back to the original object. Inverse properties are specified in templates using the suffix <code>$in</code> to the name of the property.
	      <br/>
	      The following example uses inverse properties to retrieve the winners of the Nobel Prize born in each country stored in the graph:

	      <div class="example row" id="ex13">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex13-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex13-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex13-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Data Types</h3>
	      The library supports the main JavaScript data types as values: strings, numbers (floats), boolean, dates, arrays and <code>null</code> values. The following example shows how different values can be inserted and queried using the library:

	      <div class="example row" id="ex14">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex14-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex14-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex14-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>



	      The library manages properties as sets of values. If two assertions for the same property of the same node are loaded into the graph, the returned representation of that node will include an array with both values. In the same way, loading a JSON object with an array as value will be transformed in as many data assertions as elements are in the array. Since property values are sets, it also means that there cannot be duplicated values. In order to model duplicated values or impose a certain order in the values of a property, values must be transformed into proper nodes.
	      
	      <h3>Filters</h3>

	      More expressive restrictions can be added to query templates using filters. Filters are encoded in templates as JSON objects with a single filter property. Available filters are:

	      <ul>
		<li><code>$eq</code>: equality</li>
		<li><code>$neq</code>: inequality</li>
		<li><code>$gt</code>: greater than</li>
		<li><code>$gte</code>: greater than or equals</li>
		<li><code>$lt</code>: less than</li>
		<li><code>$lte</code>: less than or equals</li>
		<li><code>$like</code>: regular expression matching</li>
	      </ul>

	      More complex filters can be composed using the following connectors:

	      <ul>
		<li><code>$and</code>: conjunction</li>
		<li><code>$or</code>: disjunction</li>
		<li><code>$not</code>: negation</li>
	      </ul>

	      The following example shows how filters can be used to retrieve certain nodes from the graph representing words in different languages:

	      <div class="example row" id="ex15">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex15-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex15-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex15-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Results Processing</h3>
	      
	      Once a query template has been defined using the <code>where</code> function, evaluation of the query can be triggered using the <code>all</code> or <code>first</code> functions. Both functions accept a callback as a parameter where all the nodes matching the query, in the case of the <code>all</code> function, or the first node in the case of the <code>first</code> function, will be returned. If no node matches the query then callbacks will receive an empty array and <code>null</code> respectively.
	      <br/>
	      Additionally, a <i>post-processing</i> function can be specified if the query is triggered using the <code>all</code> function. This function will be used to transform the query result before passing the nodes to the <code>all</code> function.
	      <br/>
	      Available post-processing functions are:

	      <ul>
		<li><code>map</code>: It will be invoked for each obtained result, the output collected and then passed to the <code>all</code>/ function.</li>
		<li><code>each</code>: It will be invoked for each obtained result and the output ignored. Invoked only for side-effects.</li>
		<li><code>select</code>: The callback function passed to this function must be a predicate returning <code>true</code> or <code>false</code>. It will be applied to each result and only nodes evaluated to <code>true</code> by the predicate will be returned.</li>
		<li><code>reduce</code>: Accepts an initial value and a callback that will e used to reduce the results collection. The final value of the accumulator will be returned to the <code>all</code> function.
		<li><code>groupBy</codE>: Groups the results, using the provided name of property or function predicate. The final result will be a JSON objects with as many properties as groups are collected.
	      </ul>

	      The following examples shows how post-processing function can be used to transform the final result of a query:

	      <div class="example row" id="ex16">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex16-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex16-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex16-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Multiple post-processing functions can be specified and they will be applied in the same definition order to the query results. The only exception is the <code>groupBy</code> function that will only be applied once as the final post-processing step.
	      <br/>
	      The following example shows how different functions can be applied to the initial results:

	      <div class="example row" id="ex16b">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex16b-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex16b-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex16b-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Order and Pagination</h3>
	      
	      Sometimes it is convenient to retrieve only a subset of the results of a query. Micrograph.js supports this functionality using the <code>limit</code> and <code>offset</code> functions. These two functions can be used to paginate the results obtained from the graph.
	      Since collections of nodes are manipulated like sets by the library it is required to impose an order in the collection to retrieve a meaningful partition of the nodes, the <code>order</code> function can be used to transform the set of resulting nodes into an ordered collection.
	      <br/>
	      The following shows the use of pagination with a simple collection of objects:

	      <div class="example row" id="ex17">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex17-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex17-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex17-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Tuple Queries</h3>

	      Tuple queries are similar to node queries but instead of returning full nodes as JSON objects, they return all the possible combinations of values for the variables in the query template. Variables can be created using the <code>_</code> (underscore) function of the graph object. The <code>_</code> function receives as an argument a name for the variable that will be returned later as the property name in the bindings returned in the solution. As a convenience variables from <code>_a</code> to <code>_z</code> are already defined as properties of the graph object. 
	      <br/>
	      To trigger the query, the <code>tuples</code> function must be invoked. Filters, pagination and the rest of query utilities are also available for tuple queries.
	      <br/>
	      The following example shows how tuple queries can be used combined with other query utilities:

	      <div class="example row" id="ex18">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex18-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex18-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex18-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>


	      <h3>Traversals</h3>
	      
	      Simple graph traversals are supported by the library and can be inserted into query patterns through path expressions. Path expressions consist of a series of properties separated by the <code>/</code> (slash) symbol plus some additional wildcards: 
	      <ul>
		<li><code>*</code> 0..n occurrences of the property.</li>
		<li><code>?</code> 0..1 occurrences of the property.</li>
		<li><code>+</code> 1..n occurrences of the property.</li>
	      </ul>
	      Paths can be inserted into node and tuple queries but can also be used with the <code>traverse</code> function to retrieve pairs of nodes collected by the graph traversal. Additionally the functions <code>startNode</code> or <code>endNode</code> can be used to bind the initial or final node of the traversal.
	      <br/>
	      Traversals can be triggered using the <code>tuples</code> or <code>all</code> functions that will return plain tuples of full nodes as the result of the traversal in each case.
	      <br/>
	      The following examples shows how traversals can be used to query hierarchical data structures stored in the graph:

	      <div class="example row" id="ex19">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex19-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex19-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex19-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      

	    </div>
	  </div> <!-- end of queries -->

	  <div class="row">
	    <div class="span10">
	      <h2 id="updates">Data Modification</h2>
	      
	      Data loaded into the graph using <code>load</code> can be modified using the <code>updateNode</code> function. This function receives a JSON object with the updated state for a node in the graph, replacing its data. The JSON object passed as an argument must identify a node in the graph, and as a consequence, it must have a <code>$id</code> property, otherwise, the function will throw an exception. If other nodes with IDs are linked to this node, the edges of the graph will be updated accordingly but their state will not be modified. If nodes without ids are linked, new nodes will be created for them in the graph.
	      <br/>
	      By default, <code>updateNode</code> only process outgoing links. Inverse links through <code>$in</code> properties are ignored. If these links must be processed, a <code>true</code> value must be passed as the second argument of the function.
	      <br/>
	      The following example shows how a node in the graph can be updated using the <code>updateNode</code> function. It also shows how inverse links are not removed by default.

	      <div class="example row" id="ex20">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex20-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex20-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex20-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      <h3>Data Deletion</h3>

	      In order to remove data from the graph, the functions <code>removeNodes</code> and <code>remove</code> can be used. Both functions are applied to the results of a query. <code>removeNodes</code> will remove all the nodes, returned by a node query. <code>remove</code> will remove the assertions matched by a tuple query. Additionally, a <code>removeNode</code> function is available in the graph object accepting a node or node identifier.
	      <br/>
	      The following example shows how <code>removeNodes</code> can be used to modify the data graph:

	      <div class="example row" id="ex21">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex21-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex21-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex21-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      This is a variation of the previous example but using <code>remove</code> and a tuple query. In this case all the nodes are still in the graph and only the 'data' property assertions have been removed:

	      <div class="example row" id="ex22">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex22-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex22-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex22-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      

	    </div>	      
	  </div> <!-- end of data modification -->

	  <div class="row">
	    <div class="span10">
	      <h2 id="events">Events</h2>
	      
	      The library implements an events notification system that allows users to register queries in the graph that will be re-evaluated each time a modification in the graph changes the result of the query. Queries are registered using the <code>bind</code> function receiving a query and a callback.
	      <br/>
	      The following example shows how a simple query can be observed using the <code>bind</code> function and the <code>map</code> post-processing function:

	      <div class="example row" id="ex23">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex23-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex23-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Observer functions receive notifications when any node returned by the query suffers a modification. The following example shows how re-evaluation of the query takes place when a nested node returned in the results is modified:


	      <div class="example row" id="ex24">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex24-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex24-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex24-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      Callbacks can be removed from the graph using the <code>unbind</code> function accepting the function object to be removed. Additionally, invocation of the callback function receives as the last parameter a query identifier that can also be passed to <code>unbind</code> to remove the callback.
	      <br/>
	      The following code snippet shows the use of the query identifier additional parameter and the <code>unbind</code> function:

	      <div class="example row" id="ex25">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex25-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex25-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      
	      <h3>Dealing with APIs</h3>

	      The library supports a couple of additional default callbacks: <code>onUpdate</code> and <code>onDelete</code>. Functions registered using these callbacks will be invoked each time a node in the graph is updated or deleted. This functions can be used to deal with remote APIs in order to update the remote state of a node stored in the graph or remove the associated resource. Special properties added by the graph to the JSON representation of nodes can be removed using the <code>toJSON</code> function.
	      <br/>
	      The following example shows how changes in the state of a graph can be tracked using the <code>onUpdate</code> and <code>onDelete</code> functions:

	      <div class="example row" id="ex25b">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex25b-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex25b-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      When wokring with an external RESTful API the API should generate the URI identifying new created resources. These resources might be created in the JavaScript application and be already stored in the graph. The <code>setId</code> method makes it possible to rebind the created node using the ID, usually an URI, generated by the remote service. Additionally, the function <code>setState</code> can be used to update the state on a node stored in the graph. This function can be used to set the state of a node form <code>modified</code> to <code>loaded</code> after a local modification of a node that has already being synched with the server using a HTTP <code>PUT</code> request.

	    </div>
	  </div><!-- end of events -->

	  <div class="row">
	    <div class="span10">
	      <h2 id="classes">Classes</h2>
	      
	      Practical use of the data in the graph usually requires to associate logic to the data. The library supports this functionality through the use of <i>classes</i> where a set of JavaScript functions plus an initializer can be associated to a set of nodes in the graph through a <i>class description</i> Class descriptions are just literal expressions combining restrictions about properties and types for the desired class members.
	      <br/>
	      The following restrictions can be used in the definition of classes:
	      <ul>
		<li><code>prop(propertyName)</code>: restriction on the presence of a property data assertion.</li>
		<li><code>typeName</code>: All instances of this classes are nodes in the graph with a data assertion for that type</li>
		<li><code>and</code>: intersection of instances</li>
		<li><code>or</code>: union of instances</li>
		<li><code>not</code>: complement of instances</li>
	      </ul>

	      Classes are declared using the <code>define</code> function. This function accepts a class expression and a prototype object whose methods will be added to every node that is an instance of this class. Optionally, prototype objects may declare a <code>init</code> function that will be invoked whenever a node is included in the class extension.
	      <br/>
	      In order to transform plain JSON node representations into instances, the function <code>instances</code> can be invoked after a query. As a result membership to the defined classes will be tested for every node in the result set, initializers invoked and functions added to the object prototypes. Membership check is performed in the declaration order of the classes. As a result, classes may override other classes functions if they declare the same function.
	      <br/>
	      The following example shows how classes may be used to add additional behaviour to the graph nodes:

	      <div class="example row" id="ex26">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="data-tab">data</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex26-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex26-data-tab" class="tab-content data-tab-content span11" style="display:none"></div>
		  <div id="ex26-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>


	    </div>
	  </div><!-- end of classes -->

	  <div class="row">
	    <div class="span10">
	      <h2 id="microdata">Microdata</h2>

              The library offers support for the incoming <a href="http://dev.w3.org/html5/md/">HTML5 Microdata specification</a>. In order to extract Microdata from a page,
	      the <code>media</code> option with value <code>microdata</code> must be passed as an argument to the <code>from</code> function.
	      Microdata data model describes a tree of data that is inserted directly into the data graph. Microdata attributes <code>itemtype</code> and <code>itemid</code> are transformed into <code>$type</code> and <code>$id</code> properties for the nodes inserted in the graph.
	      <br/>
	      Microdata specification uses URIs to identify the value of <code>itemtype</code> attributes as well as values for properties embeded in different attributes. If the URI found in these attributes is a relative URI, the parser will use the base URI of the document retrieved to form an absolute URI. The option <code>base</code> can be passed in the option hash for the <code>from</code> to define the right base URI when using JSONP or a proxy.
	      <br/>
	      The following example shows how microdata can be parsed and inserted into the graph from <a href="http://www.imdb.com/title/tt0264235/">IMDB</a> for a TV series. Since IMDB does not support <a hef="http://www.w3.org/TR/cors/">CORS</a> requests, we must use JSONP and a proxy service to retrieve the content of the page.

	      <div class="example row" id="ex27">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex27-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex27-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>
	      
	    </div>
	  </div><!-- end of microdata -->

	  <div class="row">
	    <div class="span10">
	      <h2 id="rdf">RDF</h2>

	      The library can be extended to work with <a href="http://www.w3.org/RDF/">RDF</a> data. An extension for <a href="http://www.w3.org/TeamSubmission/turtle/">N3/Turtle</a> data using Tabulator's N3 parser is available. Additional parsers for other RDF serializations like <a href="http://www.w3.org/TR/xhtml-rdfa-primer/">RDFa</a> and <a href="http://json-ld.org/spec/latest/json-ld-syntax/">JSON-LD</a> will be added eventually. RDF is the foundational technology of the Semantic Web. Its data model is powerful and much more expressive than the graph data model used by micrograph.js, including blank nodes, collections, extensible data types or language tags for literals.
	      <br/>
 In order to add RDF data to the graph, some changes in RDF data model were required:
	      <ul>
		<li>Blank nodes are assigned unique IDs</li>
		<li>Object values with a JavaScript compatible data type, like <code>xsd:float</code> is transformed into a native JavaScript object</li>
		<li>Object values with an unsupported data type are transformed into full nodes with <code>$id</code>, <code>value</code> and  <code>datatype</code> properties.</li>
		<li>Literals with language tags are ignored unless the user selects the language as an option using the <code>lang</code> <code>from</code> option.</li>
	      </ul>

	      RDF uses URIs to identify objects in the RDF graph but also to identify properties linking nodes to values or other nodes. When dealing with RDF nodes, using whole URIs as property names can be cumbersome. The library offers two solutions for this problem. A <code>ns</code> property with a hash of URI prefixes and namespace identifiers can be passed to the <code>from</code> function. In this case, URIs will be tranformed into <a href="http://www.w3.org/TR/curie/">CURIEs</a> of the form : <code>ns:value</code>. The library already defines some prefixes for some common RDF vocabularies like FOAF or Dublin Core.
	      <br/>
	      Additionally, the <code>compactProperties</code> option can be set to true in the <code>from</code> function. In this case, all property URIs will be trimmed to their last fragment. Use of this option may cause that different properties sharing the same suffix become the same property.
	      <br/>
	      The following example shows how to use the N3 parser and a CORS request to retrieve information about the city of <a href="http://dbpedia.org/page/Barcelona">Barcelona from DBPedia</a>. It also shows how to use the <code>ns</code> option to produce simpler property names.
	      
	      <div class="example row" id="ex28">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex28-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex28-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	      In this example we request information about the Facebook Platform using <a href="http://developers.facebook.com/docs/reference/api/">Facebook's Graph API</a> and use the <code>compactProperties</code> to remove obtain literal names for the RDF property URIs:

	      <div class="example row" id="ex29">
		<div class="tabs-options span11">
		  <div>
		    <span><a href="#" class="source-tab selected-tab">source</a></span>
		    <span><a href="#" class="output-tab">output</a></span>
		  </div>
		</div>
		<div class="row">
		  <div id="ex29-source-tab" class="tab-content source-tab-content span11"></div>
		  <div id="ex29-output-tab" class="tab-content output-tab-content span11" style="display:none"></div>
		</div>
	      </div>

	    </div>
	  </div><!-- end of rdf -->


	</div>
      </div>



    </div> <!-- /container -->
      <script>
	//var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
	//(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
	//g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
	//s.parentNode.insertBefore(g,s)}(document,'script'));
      </script>
  </body>
</html>
